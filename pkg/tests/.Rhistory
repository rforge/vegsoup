tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
#
cmb <- test <- test[, c(1, 3, 4, 6)]#
#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}
test
cmb
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
#
cmb <- test <- test[, c(1, 3, 4, 6)]#
#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"
test
cmb
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (verbose) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
}
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (verbose) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
}
cmb[, sel]
sel
table(sel)
dim(table(sel))
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1) stop("i don't know what to choose") #
if (verbose) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
}
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1)  #
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
	stop("i don't know what to choose")#
}
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
	stop("i don't know what to choose")#
}
#
#
#
#
#
x <- TRUE#
y <- FALSE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
	stop("\ni don't know what to choose")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
	stop("\ni don't know what to choose")#
}
table(sel)
	cat("supplied", paste(cmb[, sel], collapse = " and "))
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1 | table(sel) == 4) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "))#
	stop("\ni don't know what to choose")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1 | table(sel) == 4) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1 | table(sel) == 4) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	cat("\ni don't know what to choose")#
	stop()#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- TRUE#
file.y <- TRUE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1 | table(sel) == 4) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- FALSE#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (dim(table(sel)) > 1 | table(sel) == 4) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose?")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- FALSE#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)
sel
all(sel == FALSE)
dim(table(sel)) > 1
table(sel)
sel
sum(as.numeric(sel))
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- FALSE#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (sum(as.numeric(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose?")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- T#
file.y <- FALSE#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (sum(as.numeric(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose?")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- T#
file.y <- T#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (sum(as.numeric(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose?")#
}
#
#
#
#
#
x <- TRUE#
y <- TRUE#
file.x <- F#
file.y <- F#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = x, y = y, file.x = file.x, file.y = file.y)#
#
for (i in seq(along = tmp)) {#
 test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (sum(as.numeric(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose?")#
}
test
cmb
sel
which(sel)
source("/Users/roli/Documents/vegsoup/pkg/R/Vegsoup-Misc.R")
QueryTaxonomy(x = species, y = taxonomy)
#
#
#
QueryTaxonomy <- function (x, y, file.x, file.y, csv2 = TRUE, verbose = FALSE) {#
#
test <- combn(c("x", "y", "file.x", "file.y"), 2)#
cmb <- test <- test[, c(1, 3, 4, 6)]#
tmp <- c(x = missing(x), y = missing(y), file.x = missing(file.x), file.y = missing(file.y))#
#
for (i in seq(along = tmp)) {#
	test[test == names(tmp[i])] <- tmp[i]#
}#
#
mode(test) <- "logical"#
#
sel <- apply(test, 2, all)#
if (all(sel == FALSE)) stop("please supply x respectively file.x and y respectively file.y")#
if (sum(as.numeric(sel)) > 1) {#
	cat("supplied", paste(cmb[, sel], collapse = " and "), "\n")#
	stop("\ni don't know what to choose?")#
}#
#
if (which(sel) == 1) {#
	species <- x#
	taxonomy <- y		#
}#
#
if (which(sel) == 2) {#
	species <- x#
	taxonomy <- ifelse(csv2,#
		read.csv2(file.y, stringsAsFactors = FALSE, check.names = FALSE),#
		read.csv(file.y, stringsAsFactors = FALSE, check.names = FALSE))	#
}#
#
if (which(sel) == 3) {#
	species <- ifelse(csv2,#
		read.csv2(file.x, stringsAsFactors = FALSE, check.names = FALSE),#
		read.csv(file.x, stringsAsFactors = FALSE, check.names = FALSE))#
	taxonomy <- y#
}#
#
if (which(sel) == 4) {#
	species <- ifelse(csv2,#
		read.csv2(file.x, stringsAsFactors = FALSE, check.names = FALSE),#
		read.csv(file.x, stringsAsFactors = FALSE, check.names = FALSE)#
		)#
	taxonomy <- ifelse(csv2,#
		read.csv2(file.y, stringsAsFactors = FALSE, check.names = FALSE),#
		read.csv(file.y, stringsAsFactors = FALSE, check.names = FALSE))#
}#
#
#
taxonomy <- taxonomy[c("abbr", "taxon")]#
#
#
rownames(taxonomy) <- taxonomy$abbr#
#
res <- taxonomy[as.character(unique(species$abbr)), ]#
if (any(is.na(res[, 1]))) {#
	test <- as.character(unique(species$abbr))[is.na(res[,1])]#
	warning("not found the following abbrevation(s) in supplied reference list")#
	print(test)#
}#
return(res)#
}
QueryTaxonomy(x = species, y = taxonomy)
QueryTaxonomy
QueryTaxonomy(x = species, y = taxonomy)
file = "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species multicolumns.csv"
			x <- read.csv2(file,#
				stringsAsFactors = FALSE, check.names = FALSE)
head(file)
file = "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species multicolumns.csv"
			x <- read.csv2(file,#
				stringsAsFactors = FALSE, check.names = FALSE)
head(x)
x[,1]
	grep(c("plot", "abbr", names(x))
	grep(c("plot", "abbr", names(x)))
			x <- read.csv2(file,#
				stringsAsFactors = FALSE, check.names = FALSE)
names(x)
	grep(c("plot", "abbr", names(x)))
	grep(c("plot", "abbr"), names(x))
	regexpr(c("plot", "abbr"), names(x))
gregexpr(c("plot", "abbr"), names(x))
names(x)
	match(c("plot", "abbr"), names(x))
	sel <- match(c("plot", "abbr"), names(x))
	names(x)[-sel]
		cat("found layers", layers)
	layers <- names(x)[-sel]
		cat("found layers", layers)
		cat("found layers:", layers)
		cat("attempt to use columns:", layers, "as layer")
which(layers, names(x))
match(layers, names(x))
layers
layeras <- cbind(layers, match(layers, names(x)))
layers <- cbind(layers, match(layers, names(x)))
layers
layers <- data.frame(layers, j = match(layers, names(x)))
layers
	sel <- match(c("plot", "abbr"), names(x))#
	layers <- names(x)[-sel]#
	if (verbose) {#
		cat("attempt to use columns:", layers, "as layer")	#
	}
layers <- data.frame(layers, j = match(layers, names(x)))
layers
layers <- data.frame(layers, index = match(layers, names(x)))
	sel <- match(c("plot", "abbr"), names(x))#
	layers <- names(x)[-sel]#
	if (verbose) {#
		cat("attempt to use columns:", layers, "as layer")	#
	}
layers <- data.frame(layers, index = match(layers, names(x)))
layers
res <- x
?tukeyHSD
?tukey.HSD
?Tukey.HSD
?TukeyHSD
layers
layers[1,1]
layers[1,2]
	sel <- match(c("plot", "abbr"), names(x))#
	layers <- names(x)[-sel]#
	if (verbose) {#
		cat("attempt to use columns:", layers, "as layer")	#
	}
layers <- data.frame(layers, index = match(layers, names(x)),#
	stringsAsFactors = FALSE)
	sel <- match(c("plot", "abbr"), names(x))#
	layers <- names(x)[-sel]
layers <- data.frame(layers, index = match(layers, names(x)),#
	stringsAsFactors = FALSE)
layers[1,2]
layers[1,1]
sel
	plot.abbr <- match(c("plot", "abbr"), names(x))#
	layers <- names(x)[-plot.abbr]
layers <- data.frame(layers, index = match(layers, names(x)),#
	stringsAsFactors = FALSE)
apply(layers, 1, function (x) cbind(x[1], as.matrix(res[, c(plot.abbr, x[2])]))
)
res <- x
apply(layers, 1, function (x) cbind(x[1], as.matrix(res[, c(plot.abbr, x[2])])))
plot.abbr
x
layers[1,1]
layers[1,2]
apply(layers, 1, function (x) cbind(x[1,1], as.matrix(res[, c(plot.abbr, x[1,2])])))
apply(layers, 1, function (x) cbind(x[1], as.matrix(res[, c(plot.abbr, x[2])])))
head(res)
layers
	x <- layers[1,]
x
x[1]
res[, c(plot.abbr, x[2])]
x[2]
res[,x[2]]
class(x[2])
class(as.vector(x[2]))
as.vector(x[2])
as.integer(x[2])
res[, c(plot.abbr, as.integer(x[2]))]
apply(layers, 1, function (x) cbind(x[1], as.matrix(res[, c(plot.abbr, as.integer(x[2]))] )))
apply(layers, 1, function (x) cbind(x[1], as.matrix(res[, c(plot.abbr, as.integer(x[2]))] )),#
	simplify = FALSE)
?apply
res <- apply(layers, 1, function (x) cbind(x[1], as.matrix(res[, c(plot.abbr, as.integer(x[2]))] )))
dim(res)
head(res)
res
stack(res)
dim(res)
dim(res)/ncol(res)
res[,1]
res <- x
for (i in layers) {#
res <- rbind(#
	cbind(layers[i, 1], as.matrix(res[,c(plot.abbr, layers[i, 2])]))#
}
for (i in layers) {#
res <- rbind(res#
	cbind(layers[i, 1], as.matrix(res[,c(plot.abbr, layers[i, 2])])))#
}
for (i in layers) {#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(res[,c(plot.abbr, layers[i, 2])])))#
}
for (i in layers) {#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(res[,c(plot.abbr, as.integer(layers[i, 2]))] )))#
}
nrow(layers)
for (i in 1:nrow(layers)) {#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(res[,c(plot.abbr, as.integer(layers[i, 2]))] )))#
}
i = 1
as.matrix(res[,c(plot.abbr, as.integer(layers[i, 2]))] )
as.integer(layers[i, 2])
c(plot.abbr, as.integer(layers[i, 2]) )
res[,c(plot.abbr, as.integer(layers[i, 2]) )]
c(plot.abbr, as.integer(layers[i, 2]) )
head(res)
res <- x
for (i in 1:nrow(layers)) {#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(res[, c(plot.abbr, as.integer(layers[i, 2]) )] )))#
}
res <- x
i = 1
for (i in 1:nrow(layers)) {#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] )))#
}
head(x)
x <- read.csv2(file,#
				stringsAsFactors = FALSE, check.names = FALSE)
for (i in 1:nrow(layers)) {#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] )))#
}
res
 x
i = 1
rbind(res,#
	cbind(layers[i, 1], as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] )))
as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] )
cbind(layers[i, 1], as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] ))
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] )))
res <- c()#
for (i in 1:nrow(layers)) {#
#
res <- rbind(res,#
	cbind(layers[i, 1], as.matrix(x[, c(plot.abbr, as.integer(layers[i, 2]) )] )))#
}
head(res)
res <- as.data.frame(res,#
	stringsAsFactors = FALSE)
res[,c(2,3,1,4)]
res <- res[,c(2,3,1,4)]
names(res) <- c("plot", "abbr", "layer", "cov")
res$cov
res <- res[res$cov != "0",]
res <- res[res$cov != "",]
head(res)
res
res <- res[order(res$plot, res$abbr, res$layer)]
res <- res[order(res$plot, res$abbr, res$layer),]
res
source("/Users/roli/Documents/vegsoup/pkg/R/Vegsoup-Misc.R")
library(vegsoup)
source("/Users/roli/Documents/vegsoup/pkg/R/Vegsoup-Misc.R")
df <- ReshapeMultiCoverColumns("/Users/roli/Dropbox/traunsee/dta/csv/relevees/species multicolumns.csv")
df <- ReshapeMultiCoverColumns(file = "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species multicolumns.csv")
df
write.csv2(df, "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species.csv2", rownmaes = FALSE)
write.csv2(df, "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species.csv2", rownames = FALSE)
write.csv2(df, "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species.csv2", row.names = FALSE)
write.csv2(df, "/Users/roli/Dropbox/traunsee/dta/csv/relevees/species.csv", row.names = FALSE)
?citation
citation()
library(MCMCglmm)
install.packages(MCMCglmm)
install.packages("MCMCglmm")
install.packages(MCMCglmm)
library(MCMCglmm)
101825.655 - 100225.655
10180-1600
-10180 + 1600
-101800 + 1600
330400 - 800
330400 + 800
? kmeans
library(vegan)
?decostand
source("/Users/roli/Documents/vegsoup/pkg/R/VegsoupDataPartition-Methods.R")
library(dataframes2xls)
28/16
2/16
seq(28, 30, by = 0.125)
16*0.125
2/15
seq(28, 30, by = 0.1333333)
#
#
#
#
#
#
#
#
OptimStride <- function (obj, k, ft.treshold = 1e-3, alternative = "two.sided", method = c("ward", "flexible", "pam", "kmeans", "wards"), CALL = match.call(), ...) {#
	if (missing(k)) stop("please supply k for stride")#
	#
	cycle <- function (obj, k, ...) {#
		prt <- VegsoupDataPartition(obj, k = k, ...)#
		ft <- FisherTest(prt, alternative = alternative)#
		res <- apply(ft < ft.treshold, 2, sum)#
		return(res)#
	}#
#
	res.i <- vector("list", length = length(method))#
	names(res.i) <- method#
#
	#
	for (i in seq(along = method)) {#
		print(method[i])#
		res.j <- vector("list", length = k)#
		names(res.j) <- 1:k#
		res.j[[1]] <- 0#
		names(res.j[[1]]) <- 1#
		pb.j <- txtProgressBar(min = 2, max = k,#
			char = '.', width = 45, style = 3)		#
		for (j in 2:k) {#
			setTxtProgressBar(pb.j, j)#
			res.j[[j]] <- cycle(obj, method = method[i], k = j, ...)#
		}#
		res.i[[i]] <- res.j#
		close(pb.j)#
	}	#
		#
	#
	res <- new("VegsoupDataOptimstride", obj)#
	#
	optimstride <- list(#
		indicators = res.i,#
		settings = list(call = match.call(),#
			args = c(as.list(match.call())[-c(1,2)])))#
	optimstride$settings$args$method <- method#
	optimstride$settings$args$ft.treshold <- ft.treshold#
	optimstride$settings$args$alternative <- alternative#
#
	res@optimstride <- optimstride#
	return(res)#
}#
#
setMethod("show",#
    signature(object = "VegsoupDataOptimstride"),#
    function (object) {#
			print(object@optimstride)#
    }#
)#
#
.summaryVegsoupDataOptimstride <- function (object, oc.treshold = 2, ...) {#
#
#
#
#
#
	obj <- object@optimstride#
	args <- obj$settings$args#
	met <- args$method#
	ind <- obj$indicators#
	ftt <- args$ft.treshold#
	oct <- oc.treshold#
	#
	tmp <- sapply(ind, function (x) sapply(x, function (x) sum(x)))#
			#
	res <- list(optimclass1 = t(tmp), optimclass2 = apply(tmp, 2, function (x) sum(x >= oct)))#
	cat("OptimStride results for k:", args$k)#
	cat("\n\nOptimClass 1 (fisher test treshold: ", ftt, "):\n", sep = "")#
	print(res$optimclass1)#
	#
	cat("#
		\nOptimClass 2 (occurence treshold: ", oct, "):\n", sep = ""#
	)#
	print(res$optimclass2)#
#
	return(invisible(res))#
}#
#
setMethod("summary",#
    signature(object = "VegsoupDataOptimstride"),#
	.summaryVegsoupDataOptimstride#
)#
#
#
#
plotOptimClass <- function (x, mode = c(1, 2)) {#
	type <-  match.arg(as.character(mode), c("1", "2"))#
	#
	if (missing(mode)) mode = "1"#
	k <- x$settings$k#
	ft.treshold <- x$settings$ft.treshold#
	oc.treshold <- x$settings$oc.treshold#
	ylim.1 <- max(sapply(x$OptimClass, function(x) max(x[, 1])))#
	ylim.2 <- max(sapply(x$OptimClass, function(x) max(x[, 2])))#
	#
	switch(mode,#
		"1" = {#
		plot(1:k, rep(max.oc, k),#
			type = "n", ylim = c(0, ylim.1),#
			xlab = "OptimClass1",#
			ylab = "No. of faithfull species",#
			sub = paste("Fisher's exact test, treshold",#
			format(ft.treshold,scientific = TRUE)))#
		for (i in seq(along = names(x$OptimClass))) {#
			xx = 1:k#
			yy = x$OptimClass[[i]][, 1]#
			lines(xx, yy, lty = i)#
		}#
	}, "2" = {#
		plot(1:k, rep(max.oc, k),#
			type = "n", ylim = c(0, ylim.2),#
			xlab = "OptimClass1",#
			ylab = paste("No. of cluster with more than", oc.treshold, "faithful species"),#
			sub = paste("Fisher's exact test, treshold",#
			format(ft.treshold,scientific = TRUE)))#
		for (i in seq(along = names(x$OptimClass))) {#
			xx = 1:k#
			yy = x$OptimClass[[i]][, 2]#
			lines(xx, yy, lty = i)#
		}	#
	})#
	legend("topright", lty = 1:length(method), legend = names(oc$OptimClass))#
}
library(sp)
? spTransform
?spTransform
libary(rgdal)
libeary(rgdal)
library(rgdal)
?spTransform
?Vegsoup
? proj4string
?Vegsoup-class
?Vegsoup
?"Vegsoup-class"
?Spatial
?spTransform
setMethod("spTransform",#
	signature("Vegsoup", "CRS"),#
	function (obj, CRSobj, ...) {#
		obj@sp.points <- spTransform(obj@sp.points, CRSobj, ...)#
		obj@sp.polygons <- spTransform(obj@sp.polygons, CRSobj, ...)	#
	}#
)
bbox(dta)
?bbox
#
#
#
VegsoupData <- function (obj, verbose = FALSE) {#
	require(stats)#
	#
	if (!inherits(obj, "Vegsoup"))#
		stop("Need object of class Vegsoup")#
#
	scale <- AbundanceScale(obj)#
	lay <- Layers(obj)#
	txa <- Taxonomy(obj)#
	species.long <- SpeciesLong(obj)#
	#
	if (scale$scale == "Braun-Blanquet" | scale$scale == "Braun-Blanquet 2") {#
		stopifnot(is.character(species.long$cov))#
		if (length(lay) == 1) {#
			if (verbose) cat("\ndata is structered in only one layer")#
		} else {#
			if (verbose) cat("\ndata is structered in layers: ", lay)#
		}#
		#
		cpu.time <- system.time({#
		#
		tmp <- as.factor(species.long$cov)#
		levels(tmp) <- scale$lims[match(levels(tmp), scale$codes)]#
		species.long$cov <- as.numeric(as.character(tmp))#
#
		xt  <- xtabs(cov ~ plot + abbr + layer, data = species.long)#
		#
		if (dim(xt)[3] > 1) {#
			res <- matrix(0,#
			ncol = dim(xt)[2] * dim(xt)[3],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(rep(dimnames(xt)$abbr, dim(xt)[3]),#
					rep(dimnames(xt)$layer,#
					each = dim(xt)[2]), sep = "@")))#
		} else {#
			res <- matrix(0,#
			ncol = dim(xt)[2],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(dimnames(xt)$abbr,#
						dimnames(xt)$layer, sep = "@")))#
		}#
		#
		#
		for (i in 1:dim(xt)[3]) {#
			sel <- grep(paste("", dimnames(xt)$layer[i], sep = "@"),#
				dimnames(res)$abbr, fixed = TRUE)#
			res[,sel] <- xt[,,i]	#
		}#
		#
		res <- res[, colSums(res) > 0]#
		res <- as.data.frame(res)#
		#
		for (i in seq(along = scale$lims)) {#
			res[res == scale$lims[i]] <- scale$codes[i]#
		}#
		species <- res#
		}) #
	} #
	#
	cpu.time <- system.time({	#
	if (scale$scale == "frequency" | scale$scale == "binary") {#
#
		if (!is.numeric(species.long$cov)) {#
			#
			mode(species.long$cov) <- "numeric"#
		}	#
		xt  <- xtabs(cov ~ plot + abbr + layer,#
			data = species.long)#
	#
		if (dim(xt)[3] > 1) {#
			res <- matrix(0,#
			ncol = dim(xt)[2] * dim(xt)[3],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(rep(dimnames(xt)$abbr, dim(xt)[3]),#
					rep(dimnames(xt)$layer,#
					each = dim(xt)[2]), sep = "@")))#
		} else {#
			res <- matrix(0,#
			ncol = dim(xt)[2],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(dimnames(xt)$abbr,#
						dimnames(xt)$layer, sep = "@")))#
		}#
		for (i in 1:dim(xt)[3]) {#
			sel <- grep(paste("", dimnames(xt)$layer[i], sep = "@"),#
				dimnames(res)$abbr, fixed = TRUE)#
			res[,sel] <- xt[,,i]	#
		}#
		res <- res[,colSums(res) > 0]#
		species <- as.data.frame(res)#
	} #
	}) #
	#
	if (verbose) {#
		cat("\ntime to cast species matrix",#
		"of", prod(dim(res)), "cells:",#
		cpu.time[3], "sec\n")#
	}#
	#
	#
	#
	#
	if (any(SitesLong(obj)[, 3] == "") | any(is.na(SitesLong(obj)[, 3]))) {#
		obj@sites.long[obj@sites.long[, 3] == "", 3] <- 0#
		obj@sites.long[is.na(obj@sites.long[, 3]), 3] <- 0#
		warning("NAs and empty fields (\"\") in supplied sites data",#
			" filled with zeros")#
	}#
	sites <- reshape(SitesLong(obj)[, 1:3],#
		direction = "wide",#
		timevar = "variable",#
		idvar = "plot")#
	#
	#
	#
	#
	#
	if (any(is.na(sites))) {#
		sites[is.na(sites)] <- 0#
		warning("NAs in casted sites data frame",#
			" filled with zeros")#
		#
		tmp <- stack(sites)#
		tmp[,1] <- as.character(tmp[,1])#
		tmp[,2] <- as.character(tmp[,2])#
		plot <- tmp[tmp$ind == "plot",]$values#
		plot <- rep(plot, (nrow(tmp)/length(plot))- 1)#
		tmp <- tmp[!tmp$ind == "plot",]#
		tmp <- data.frame(plot,#
			variable = tmp[,2],#
			value = tmp[,1])#
		tmp <- tmp[order(tmp$plot),]#
		tmp$variable <- gsub("value.", "", tmp$variable, fixed = TRUE)#
		tmp <- data.frame(as.matrix(tmp), stringsAsFactors = FALSE)#
		tmp[is.na(tmp)] <- ""#
		rownames(tmp) <- 1:nrow(tmp)#
		#
		obj@sites.long <- tmp[order(tmp$plot, tmp$variable),]#
	}#
	#
	#
	#
	options(warn = -1)#
	sites <- as.data.frame(#
		sapply(sites,#
		function (x) {#
			if (!any(is.na(as.numeric(x)))) {#
				x <- as.numeric(x)#
			} else {#
				x <- as.character(x)	#
			}#
		}, simplify = FALSE),#
		stringsAsFactors = FALSE)#
	options(warn = 0)#
	#
	#
	names(sites) <- gsub("value.", "",#
		names(sites), fixed = TRUE)#
	rownames(sites) <- sites$plot#
	sites <- sites[,-grep("plot", names(sites))]#
	sites <- sites[match(rownames(species), rownames(sites)), ]#
#
	#
	res <- new("VegsoupData", obj)#
	#
	res@species = species#
	res@sites = sites			#
#
	return(res)#
}#
#
#
#
setAs("VegsoupData", "list",#
	def = function (from) {#
		list(species = from@species,#
		sites = from@sites)#
	}#
)#
#
setMethod("names",#
    signature(x = "VegsoupData"),#
    function (x) names(x@species)#
)#
#
setMethod("rownames",#
    signature(x = "VegsoupData", do.NULL = "missing",#
    prefix = "missing"),#
    function (x) rownames(x@species)#
)#
#
setMethod("dim",#
    signature(x = "VegsoupData"),#
	    function (x) dim(x@species)#
)#
#
setMethod("nrow",#
    signature(x = "VegsoupData"),#
    function (x) nrow(x@species)#
)#
#
setMethod("ncol",#
    signature(x = "VegsoupData"),#
    function (x) ncol(x@species)#
)#
#
setMethod("head",#
    signature(x = "VegsoupData"),#
    function (x, n = 6L, choice, ...) {#
	    if (missing(choice))#
	    	choice <- "species"	#
    	if (choice == "species")#
    		res <- head(x@species)#
    	if (choice == "sites")#
    		res <- head(x@sites)#
    	return(res)#
    }    	    #
)#
#
setMethod("tail",#
    signature(x = "VegsoupData"),#
    function (x, choice, ...) {#
	    if (missing(choice))#
	    	choice <- "species"#
    	if (choice == "species")#
    		res <- tail(x@species, ...)#
    	if (choice == "sites")#
    		res <- tail(x@sites, ...)#
    	return(res)#
    }    	    #
)#
#
setMethod("rowSums",#
	signature(x = "VegsoupData"),#
	function (x, na.rm = FALSE, dims = 1) {#
    	rowSums(as.binary(x))#
    }#
)#
#
setMethod("colSums",#
	signature(x = "VegsoupData"),#
	function (x, na.rm = FALSE, dims = 1) {#
    	colSums(as.binary(x))#
    }#
)#
 #
setMethod("coordinates",#
   signature(obj = "VegsoupData"),#
    function (obj) coordinates(obj@sp.points)#
)#
#
#
setMethod("as.character",#
    signature(x = "VegsoupData"),#
    function (x) {#
    	res <- as.matrix(x@species)#
    	if (mode(res) != "character") {#
	    	mode(res) <- "character"#
    		res <- as.data.frame(res, stringsAsFactors = FALSE)#
    	} else {#
    		res <- x@species#
    	}#
    	return(invisible(res))#
    }#
)	#
#
#
#
setGeneric("as.binary",#
	function (obj, ...)#
		standardGeneric("as.binary")#
)#
#
#
setMethod("as.binary",#
    signature(obj = "VegsoupData"),#
    function (obj) {#
			res <- obj@species != "0"#
		mode(res) <- "numeric"#
		res <- as.data.frame(res)#
		return(invisible(res))#
    }#
)	#
#
#
#
#
setMethod("as.numeric",#
    signature(x = "VegsoupData"),#
    function (x, verbose = FALSE) {#
    	#
		if (AbundanceScale(x)$scale == "frequency" | AbundanceScale(x)$scale == "binary") {#
			res <- as.matrix(x@species)#
			mode(res) <- "numeric"#
			res <- as.data.frame(res)#
			if (verbose) {#
				cat("  species matrix is numeric, scale:",#
					AbundanceScale(x)$scale)#
			}#
		} else {		#
			res <- x@species#
			scale <- AbundanceScale(x)		#
			tmp <- as.factor(c(as.matrix(res)))#
			levels(tmp) <- scale$lims[match(levels(tmp), scale$codes)]#
			tmp <- as.numeric(as.character(tmp))#
			tmp[is.na(tmp)] <- 0#
			res[,] <- tmp#
		}#
		return(invisible(res))   	#
    }#
)#
#
#
setGeneric("Sites",#
	function (obj, ...)#
		standardGeneric("Sites")#
)#
setGeneric("Sites<-",#
	function (obj, value, ...)#
		standardGeneric("Sites<-")#
)#
setMethod("Sites",#
    signature(obj = "VegsoupData"),#
    function (obj) obj@sites#
)#
setReplaceMethod("Sites",#
	signature(obj = "VegsoupData", value = "data.frame"),#
	function (obj, value) {#
		#
		obj@sites <- value		#
		return(obj)		#
	}#
)#
#
setMethod("$", "VegsoupData", #
	function(x, name) {#
		if (!("sites" %in% slotNames(x)))#
			stop("no $ method for object without slot sites")#
		x@sites[[name]]#
	}#
)#
#
#
#
.LayersVegsoupData <- function (obj, collapse, aggregate = c("layer", "mean", "min", "max", "sum"), dec = 0, verbose = FALSE) {#
if (missing(collapse) & missing(aggregate)) {#
	return(obj@layers)	#
} else {#
	if (length(obj@layers) < 2) {#
		if (verbose) warning("has already only a single layer: ", obj@layers)#
		return(obj)#
	} else {#
	#
	#
	if (missing(aggregate)) {#
		aggregate <- "layer"#
	} else {#
		aggregate <- match.arg(aggregate)	#
	}#
	if (missing(collapse)) {#
		if (verbose) cat("collapse to a single layer\n")#
			collapse <- rep("0l", length(obj@layers))#
	} else {#
		if (length(collapse) > length(obj@layers))#
			stop("length of collapse vector must match length(Layers(obj))")#
	}#
	#
	#
	#
	#
	#
	if (inherits(obj, "VegsoupData")) { #
		res <- as(obj, "Vegsoup")#
	} else {#
		res <- obj#
	}#
#
	species <- SpeciesLong(res)#
	scale <- AbundanceScale(res)#
#
	collapse <- matrix(c(res@layers, collapse),#
		ncol = 2, nrow = length(res@layers),#
		byrow = FALSE,#
		dimnames = list(NULL, c("original", "collapsed")))#
	#
	if (verbose) print(collapse)	#
#
	species$layer <- factor(species$layer)#
	levels(species$layer) <- collapse[match(levels(species$layer), collapse[, 1]), 2]#
	species$layer <- as.character(species$layer)#
#
	scale.is.character <- is.character(species$cov)#
	#
	#
	if (scale.is.character) {#
		species$cov <- as.factor(species$cov)#
		levels(species$cov) <- scale$lims[match(levels(species$cov), scale$codes)]#
		species$cov <- as.numeric(as.character(species$cov))#
	}#
	#
	#
	species  <- switch(aggregate, mean = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = mean)#
	}, min = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = min)				#
	}, max = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = max)#
	}, sum = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = sum)#
	}, layer = {#
		if (scale$scale != "frequency") {#
			aggregate(cov ~ plot + abbr + layer, data = species,#
				FUN = function (x) {#
					round((1 - prod(1 - x / max(scale$lims))) * max(scale$lims), dec)#
				})#
		} else {#
			aggregate(cov ~ plot + abbr + layer, data = species,#
				FUN = function (x) {#
					round((1 - prod(1 - x / 100)) * 100, dec)	#
					})#
		}		#
	})#
	#
	species <- species[order(species$plot, species$layer, species$abbr), ]#
	#
	if (scale$scale != "frequency") {#
		if (any(max(species$cov) > max(scale$lims))) {#
			warning("reduced maximum aggregated abundance value to fit into limits: ",#
				min(scale$lims)[1], " to ", max(scale$lims))#
			species$cov[species$cov >  max(scale$lims)] <- max(scale$lims)#
	}#
	}#
	species$cov <- ceiling(species$cov)#
	#
	#
	if (scale.is.character) {	#
		species$cov <- as.factor(species$cov)#
		levels(species$cov) <- scale$codes[match(levels(species$cov), scale$lims)]#
		species$cov <- as.character(species$cov)#
	}#
	#
	res@species.long <- species#
	res@layers <- unique(collapse[, 2])#
	res <- VegsoupData(res)#
	return(invisible(res))#
#
	}#
	}#
}#
#
setMethod("Layers",#
   signature(obj = "VegsoupData"),#
    .LayersVegsoupData#
)#
#
#
.getRichnessVegsoupData <-  function (obj, choice = c("dataset", "sample"), ...) {#
	#
	choices <- c("dataset", "sample")#
	if (missing(choice)) {#
		choice <- "dataset"#
	}#
	choice <- choices[pmatch(choice, choices)]#
	if (is.na(choice)) {#
		choice <- "dataset"#
	}	#
		switch(choice, "dataset" = {#
		res <- length(unique(DecomposeNames(obj))$abbr)#
		}, "sample" = {#
		res <- as.binary(Layers(obj, aggregate = "layer", verbose = FALSE))#
		res <- rowSums(res)#
		})		#
#
	return(res)#
}#
#
setGeneric("Richness",#
	function (obj, ...)#
		standardGeneric("Richness")#
)#
setMethod("Richness",#
    signature(obj = "VegsoupData"),#
    .getRichnessVegsoupData#
)#
#
#
setGeneric("getDistconnected",#
	function (obj, ...)#
		standardGeneric("getDistconnected")#
)#
setMethod("getDistconnected",#
	signature(obj = "VegsoupData"),#
	function (obj, dis = "bray", ...) {#
		distconnected(vegdist(as.numeric(obj), dis), ...)#
	}#
)#
#
.summaryVegsoupData  <- function (object, choice = c("all", "species", "sites"), ...) {#
#
	if (missing(choice)) choice <- "all"#
		choices <- c("all", "species", "sites")#
	choice <- choices[pmatch(choice, choices)]#
	if (is.na(choice)) choice <- "all"#
	cat("object of class", class(object), "\n")#
	species.summary <- paste(#
		Richness(object), " species",#
		"\n", dim(object)[1], " sites (sample plots)",#
		"\nlayers ", length(Layers(object)),#
		" (", paste(Layers(object), collapse = ", "), ")",#
		"\nscale ", AbundanceScale(object)$scale,#
		ifelse(length(object@taxonomy) > 0,#
			"\ntaxomomy lookup table supplied ",#
			"... but has non matching taxa!"),#
		sep = ""#
	)#
#
	switch(choice, "all" = {#
		cat(species.summary)#
		cat("\nsites ")	#
		str(Sites(object), no.list = TRUE)#
	}, "species" = {#
		cat(species.summary)#
	}, "sites" = {#
		cat("\nsites ")#
		str(Sites(object))		#
	})#
}#
#
#
#
setMethod("summary",#
    signature(object = "VegsoupData"),#
	.summaryVegsoupData#
)#
#
#
#
setMethod("show",#
    signature(object = "VegsoupData"),#
    function (object) {#
			summary(object)#
    }#
)#
#
.plotVegsoupData <- function (x, y, ...)#
{	#
	if (!inherits(x, "VegsoupData"))#
		stop("\n need object of class VegsoupData")#
	if (!prod(dim(x)) < 10^5)	#
		cat("Let me calculate capscale first ...")#
	#
	warning("not implemented yet")#
}#
#
#
setMethod("plot",#
	signature(x = "VegsoupData", y = "ANY"),#
	.plotVegsoupData#
)#
#
#
#
setMethod("[",#
    signature(x = "VegsoupData",#
    i = "ANY", j = "ANY", drop = "missing"),#
	function (x, i, j, ..., drop = TRUE)#
    {#
	    #
	    #
	    res <- x#
	    if (missing(i)) i <- rep(TRUE, nrow(res))#
	    if (missing(j)) j <- rep(TRUE, ncol(res))#
#
		ii <- rowSums(as.binary(x)[i,j]) > 0 #
		if (any(ii == FALSE)) {#
			cat("\n removed empty sites:",#
				rownames(x)[i][!ii])	#
		}#
		#
		jj <- colSums(as.binary(x)[i,j]) > 0 #
		if (any(jj == FALSE)) {#
			#
			cat("\nremoved empty species!\n")#
		}#
#
		res@species <- as.character(x)[i,j][ii,jj]#
		res@species.long <-#
			res@species.long[res@species.long$plot %in%	rownames(res), ]#
		res@species.long <-#
			res@species.long[paste(res@species.long$abbr,#
				res@species.long$layer, sep = "@") %in%	names(res), ]#
		res@sites <-#
			res@sites[match(rownames(res),#
				rownames(res@sites)), ]#
		if (any(sapply(res@sites, is.na))) stop("Error")#
		#
		res@sites.long <-#
			res@sites.long[res@sites.long$plot %in%#
				rownames(res), ]#
		res@sites.long <- res@sites.long[order(res@sites.long$plot, res@sites.long$variable), ]#
		if (length(res@group) != 0) {#
		res@group <-#
			res@group[names(res@group) %in%#
				rownames(as.character(x)[i,j][ii,jj])]#
		}#
		#
		abbr <- sapply(strsplit(names(res), "@", fixed = TRUE),#
		   function (x) x[1])#
 		#
		res@taxonomy <- res@taxonomy[res@taxonomy$abbr %in% abbr, ]#
		res@sp.points <- res@sp.points[i,]#
		res@sp.polygons <- res@sp.polygons[i,]#
		res@layers <- as.character(unique(res@species.long$layer))#
	    return(res)#
    }#
)#
#
#
#
#
#
#
#
#
.VegsoupDataArrange <- function (object, method = c("dca", "hclust", "ward", "flexible", "pam", "packed"), dist = "bray", ...) {#
#
if (!inherits(object, "VegsoupData"))#
	stop("Need an object of class VegsoupData")#
#
if (missing(method)) {#
	method  <- "dca"#
	} else {#
	method <- match.arg(method)			#
}#
#
si.dis <- vegdist(as.binary(object), method = dist)#
sp.dis <- vegdist(t(as.binary(object)), method = dist)#
	#
switch(method, dca = {#
	use <- try(decorana(as.binary(object)), silent = TRUE, ...)#
	if (inherits(use, "try-error"))#
		use  <- NULL #
#
	if (is.list(use)) {	#
		tmp <- scores(use, choices = 1, display = "sites")#
		si.ind <- order(tmp)#
		sp.ind <- try(order(scores(use, choices = 1, #
                  display = "species")))#
		if (inherits(sp.ind, "try-error")) #
			sp.ind <- order(wascores(tmp, object))#
	} else {#
			si.ind <- 1:dim(as.binary(object))[1]#
			sp.ind <- 1:dim(as.binary(object))[2]#
	}#
	}, hclust = {#
		si.ind <- hclust(si.dis,#
			method = "ward")$order#
		sp.ind <- hclust(sp.dis,#
			method = "ward")$order#
	}, ward = {#
		si.ind <- agnes(si.dis, diss = TRUE,#
			method = "ward")$order#
		sp.ind <- agnes(sp.dis, diss = TRUE,#
			method = "ward")$order#
	}, flexible = {#
	   	alpha <- 0.625#
	   	beta = 1 - 2 * alpha#
	   	si.ind <- agnes(si.dis, method = "flexible",#
	   		par.meth = c(alpha, alpha, beta, 0))$order#
	   	sp.ind <- agnes(sp.dis, method = "flexible",#
	   		par.meth = c(alpha, alpha, beta, 0))$order#
	}, pam = {#
		si.ind <- agnes(si.dis, diss = TRUE,#
			method = "ward")$order#
		sp.ind <- agnes(sp.dis, diss = TRUE,#
			method = "ward")$order	#
	}, packed = {#
		si.ind <- order(apply(as.binary(object), 1, sum), decreasing = TRUE)#
		sp.ind  <- order(apply(as.binary(object), 2, sum), decreasing = TRUE)#
	}#
)#
	#
res <- object[si.ind, sp.ind]#
#
return(res)#
#
}#
#
#
setGeneric("Arrange",#
	function (object, ...)#
		standardGeneric("Arrange")#
)#
setMethod("Arrange",#
    signature(obj = "VegsoupData"),#
    .VegsoupDataArrange#
)#
#
#
#
			#
setGeneric("Indpower",#
	function (obj, ...)#
		standardGeneric("Indpower")#
)#
#
setMethod("Indpower",#
    signature(obj = "VegsoupData"),#
    function (obj, ...) {#
    	res <- indpower(as.binary(obj), ...)#
    	diag(res)  <- NA#
    	if (type == 0)#
			res <- rowMeans(res, na.rm = TRUE)#
		return(res)    	#
    }#
)#
#
#
#
setGeneric("Indspc",#
	function (obj, ...)#
		standardGeneric("Indspc")#
)#
#
setMethod("Indspc",#
    signature(obj = "VegsoupData"),#
    function (obj, method, ...) {#
    	if (inherits(obj, "VegsoupDataPartition")) {#
    		dis <- vegdist(as.binary(obj), obj@dist)#
    	} else {#
   			if (missing(method)) {    			#
				dis <- vegdist(as.binary(obj), "bray")#
    		} else {#
    			dis <- vegdist(as.binary(obj), ...)#
    		}    		#
  	 	}#
    	res <- indspc(as.binary(obj), dis = dis, ...)#
		return(res)    	#
    }#
)#
#
	#
#
.DecomposeNamesVegsoupData <- function (obj, verbose = FALSE) {#
#
if (verbose)#
	cat("\n use Vegsoup standard pattern taxa coding, blanks are dots")#
#
#
#
	#
#
#
#
abbr <- sapply(strsplit(names(obj), "@", fixed = TRUE),#
		   function (x) x[1])#
layer <- sapply(strsplit(names(obj), "@", fixed = TRUE),#
		   function (x) x[2])#
#
taxon <- Taxonomy(obj)$taxon[match(abbr, Taxonomy(obj)$abbr)]#
res <- data.frame(abbr.layer = names(obj), abbr, layer, taxon, stringsAsFactors = FALSE)#
#
#
if (all(is.na(res$layer))) {#
	warning("unable to deparse layer string, consider setting type to nospace")#
}#
if (all(is.na(res$taxon))) {#
	warning("unable to deparse taxon string, consider setting type to nospace")#
}#
return(invisible(res))#
}#
#
#
setGeneric("DecomposeNames",#
	function (obj, ...)#
		standardGeneric("DecomposeNames")#
)#
#
#
setMethod("DecomposeNames",#
	signature(obj = "VegsoupData"),#
	.DecomposeNamesVegsoupData#
)#
#
#
setMethod("Abbreviation",#
    signature(obj = "VegsoupData"),#
    function (obj, ...) DecomposeNames(dta)$abbr#
)#
#
#
#
#
#
.strideVegsoupData <- function (obj, method, stride, fidelity.method, partition.method, mode, verbose = TRUE, alpha = 0.05, ...) {#
#
	if (missing(fidelity.method))#
		fidelity.method = "IndVal.g"#
	if (missing(partition.method))#
		partition.method = "flexible"#
	if (missing(stride))#
		stride = ceiling(ncol(obj) / 10)#
	if (missing(mode))#
		mode = 0#
	if (verbose) {#
		cat("compute", stride, "partitions for stride")#
		cat("\nrun SigFidelity with mode", mode)#
	}#
#
res <- vector("list", length = stride)#
names(res) <- 1:stride#
#
if (verbose) {#
	pb.stride <- txtProgressBar(min = 1, max = stride,#
	char = '.', width = 45, style = 3)#
}#
#
cpu.time <- system.time({#
for (i in 1:stride) {#
	if (verbose) {#
		setTxtProgressBar(pb.stride, i)#
	}#
	i.prt <- VegsoupDataPartition(obj, k = i, method = partition.method)#
	i.fid <- Fidelity(i.prt, method = fidelity.method, verbose = FALSE)#
	stat.fid <- apply(getStat(i.fid), 1, sum)#
#
	if (i > 1) {#
		i.sig.fid <- SigFidelity(i.prt, verbose = FALSE)#
		i.sig.fid <- length(which(i.sig.fid$stat < alpha))#
	} else {#
		i.sig.fid <- 0#
	}#
	res[[i]] <- list(stat = stat.fid, n.sig = i.sig.fid)#
}#
#
#
stat <- sapply(res, function (x) x[[1]])#
n.sig <- sapply(res, function (x) x$n.sig)#
diff.stat <- t(rbind(0, apply(stat, 1, diff)))#
diff.stat <- apply(diff.stat, 2,#
	function(x)	c(sum(x[x > 0]), sum(x[x < 0])))#
})	#
if (verbose) {#
	close(pb.stride)#
	cat("\n  computed stride in", cpu.time[3], "sec")#
}#
res <- list(#
	stat = stat,#
	n.sig = n.sig,#
	diff.stat = diff.stat)#
	#
return(invisible(res))#
}#
#
setGeneric("Stride",#
	function (obj, ...)#
		standardGeneric("Stride")#
)#
setMethod("Stride",#
	signature(obj = "VegsoupData"),#
	.strideVegsoupData	#
)#
#
#
plotStride <- function (x) {#
#
	xx <- 1:(ncol(x$stat)) #
	y1 <- x$diff.stat[1, ]#
	y2 <- x$diff.stat[2, ]#
	ylim  <- range(x$diff.stat)#
	#
	r1 <- t(rbind(xright = xx - 0.5, ybottom = 0,#
		xright = xx + 0.5, ytop = y1))#
	r2 <- t(rbind(xright = xx - 0.5, ybottom = y2,#
		xright = xx + 0.5, ytop = 0))#
	bars <- cbind(xx, c(x$n.sig))[-1,] #
	#
#
	#
	par(mar= rep(4,4))#
	plot(xx, y1, xlim = c(1, max(xx)),#
		ylim = range(x$diff.stat), type = "n",#
		xlab = "Cluster", ylab = "Index", frame.plot = FALSE) #
	#
	apply(r1, 1, function (x) rect(x[1], x[2], x[3], x[4],#
		col = "grey50"))#
	#
	apply(r2, 1, function (x) rect(x[1], x[2], x[3], x[4],#
		col = "grey90"))#
	#
	plot.window(xlim = range(xx), ylim = range(bars[,2]))#
	lines(xx[-1], bars[,2], type = "b",#
		pch = 16, col = 2, lwd = 2, cex = 1)#
	axis(4, col = 1, lwd = 1)	#
	#
	plot.window(xlim = range(xx),#
		ylim = range(apply(x$diff.stat, 2, sum)))#
	lines(xx, apply(x$diff.stat, 2, sum),#
		type = "b", pch = 15, cex = 1)#
	#
	#
#
#
		#
	legend("top", lty = 1, col = c(1,2),#
		legend = c("sum of all differences",#
		"number of significant indicator species"),#
		bty = "n")#
#
#
#
#
#
#
}
library(vegsoup)
#
#
#
VegsoupData <- function (obj, verbose = FALSE) {#
	require(stats)#
	#
	if (!inherits(obj, "Vegsoup"))#
		stop("Need object of class Vegsoup")#
#
	scale <- AbundanceScale(obj)#
	lay <- Layers(obj)#
	txa <- Taxonomy(obj)#
	species.long <- SpeciesLong(obj)#
	#
	if (scale$scale == "Braun-Blanquet" | scale$scale == "Braun-Blanquet 2") {#
		stopifnot(is.character(species.long$cov))#
		if (length(lay) == 1) {#
			if (verbose) cat("\ndata is structered in only one layer")#
		} else {#
			if (verbose) cat("\ndata is structered in layers: ", lay)#
		}#
		#
		cpu.time <- system.time({#
		#
		tmp <- as.factor(species.long$cov)#
		levels(tmp) <- scale$lims[match(levels(tmp), scale$codes)]#
		species.long$cov <- as.numeric(as.character(tmp))#
#
		xt  <- xtabs(cov ~ plot + abbr + layer, data = species.long)#
		#
		if (dim(xt)[3] > 1) {#
			res <- matrix(0,#
			ncol = dim(xt)[2] * dim(xt)[3],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(rep(dimnames(xt)$abbr, dim(xt)[3]),#
					rep(dimnames(xt)$layer,#
					each = dim(xt)[2]), sep = "@")))#
		} else {#
			res <- matrix(0,#
			ncol = dim(xt)[2],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(dimnames(xt)$abbr,#
						dimnames(xt)$layer, sep = "@")))#
		}#
		#
		#
		for (i in 1:dim(xt)[3]) {#
			sel <- grep(paste("", dimnames(xt)$layer[i], sep = "@"),#
				dimnames(res)$abbr, fixed = TRUE)#
			res[,sel] <- xt[,,i]	#
		}#
		#
		res <- res[, colSums(res) > 0]#
		res <- as.data.frame(res)#
		#
		for (i in seq(along = scale$lims)) {#
			res[res == scale$lims[i]] <- scale$codes[i]#
		}#
		species <- res#
		}) #
	} #
	#
	cpu.time <- system.time({	#
	if (scale$scale == "frequency" | scale$scale == "binary") {#
#
		if (!is.numeric(species.long$cov)) {#
			#
			mode(species.long$cov) <- "numeric"#
		}	#
		xt  <- xtabs(cov ~ plot + abbr + layer,#
			data = species.long)#
	#
		if (dim(xt)[3] > 1) {#
			res <- matrix(0,#
			ncol = dim(xt)[2] * dim(xt)[3],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(rep(dimnames(xt)$abbr, dim(xt)[3]),#
					rep(dimnames(xt)$layer,#
					each = dim(xt)[2]), sep = "@")))#
		} else {#
			res <- matrix(0,#
			ncol = dim(xt)[2],#
			nrow = dim(xt)[1],#
			dimnames = list(#
				plot = dimnames(xt)$plot, #
				abbr = paste(dimnames(xt)$abbr,#
						dimnames(xt)$layer, sep = "@")))#
		}#
		for (i in 1:dim(xt)[3]) {#
			sel <- grep(paste("", dimnames(xt)$layer[i], sep = "@"),#
				dimnames(res)$abbr, fixed = TRUE)#
			res[,sel] <- xt[,,i]	#
		}#
		res <- res[,colSums(res) > 0]#
		species <- as.data.frame(res)#
	} #
	}) #
	#
	if (verbose) {#
		cat("\ntime to cast species matrix",#
		"of", prod(dim(res)), "cells:",#
		cpu.time[3], "sec\n")#
	}#
	#
	#
	#
	#
	if (any(SitesLong(obj)[, 3] == "") | any(is.na(SitesLong(obj)[, 3]))) {#
		obj@sites.long[obj@sites.long[, 3] == "", 3] <- 0#
		obj@sites.long[is.na(obj@sites.long[, 3]), 3] <- 0#
		warning("NAs and empty fields (\"\") in supplied sites data",#
			" filled with zeros")#
	}#
	sites <- reshape(SitesLong(obj)[, 1:3],#
		direction = "wide",#
		timevar = "variable",#
		idvar = "plot")#
	#
	#
	#
	#
	#
	if (any(is.na(sites))) {#
		sites[is.na(sites)] <- 0#
		warning("NAs in casted sites data frame",#
			" filled with zeros")#
		#
		tmp <- stack(sites)#
		tmp[,1] <- as.character(tmp[,1])#
		tmp[,2] <- as.character(tmp[,2])#
		plot <- tmp[tmp$ind == "plot",]$values#
		plot <- rep(plot, (nrow(tmp)/length(plot))- 1)#
		tmp <- tmp[!tmp$ind == "plot",]#
		tmp <- data.frame(plot,#
			variable = tmp[,2],#
			value = tmp[,1])#
		tmp <- tmp[order(tmp$plot),]#
		tmp$variable <- gsub("value.", "", tmp$variable, fixed = TRUE)#
		tmp <- data.frame(as.matrix(tmp), stringsAsFactors = FALSE)#
		tmp[is.na(tmp)] <- ""#
		rownames(tmp) <- 1:nrow(tmp)#
		#
		obj@sites.long <- tmp[order(tmp$plot, tmp$variable),]#
	}#
	#
	#
	#
	options(warn = -1)#
	sites <- as.data.frame(#
		sapply(sites,#
		function (x) {#
			if (!any(is.na(as.numeric(x)))) {#
				x <- as.numeric(x)#
			} else {#
				x <- as.character(x)	#
			}#
		}, simplify = FALSE),#
		stringsAsFactors = FALSE)#
	options(warn = 0)#
	#
	#
	names(sites) <- gsub("value.", "",#
		names(sites), fixed = TRUE)#
	rownames(sites) <- sites$plot#
	sites <- sites[,-grep("plot", names(sites))]#
	sites <- sites[match(rownames(species), rownames(sites)), ]#
#
	#
	res <- new("VegsoupData", obj)#
	#
	res@species = species#
	res@sites = sites			#
#
	return(res)#
}#
#
#
#
setAs("VegsoupData", "list",#
	def = function (from) {#
		list(species = from@species,#
		sites = from@sites)#
	}#
)#
#
setMethod("names",#
    signature(x = "VegsoupData"),#
    function (x) names(x@species)#
)#
#
setMethod("rownames",#
    signature(x = "VegsoupData", do.NULL = "missing",#
    prefix = "missing"),#
    function (x) rownames(x@species)#
)#
#
setMethod("dim",#
    signature(x = "VegsoupData"),#
	    function (x) dim(x@species)#
)#
#
setMethod("nrow",#
    signature(x = "VegsoupData"),#
    function (x) nrow(x@species)#
)#
#
setMethod("ncol",#
    signature(x = "VegsoupData"),#
    function (x) ncol(x@species)#
)#
#
setMethod("head",#
    signature(x = "VegsoupData"),#
    function (x, n = 6L, choice, ...) {#
	    if (missing(choice))#
	    	choice <- "species"	#
    	if (choice == "species")#
    		res <- head(x@species)#
    	if (choice == "sites")#
    		res <- head(x@sites)#
    	return(res)#
    }    	    #
)#
#
setMethod("tail",#
    signature(x = "VegsoupData"),#
    function (x, choice, ...) {#
	    if (missing(choice))#
	    	choice <- "species"#
    	if (choice == "species")#
    		res <- tail(x@species, ...)#
    	if (choice == "sites")#
    		res <- tail(x@sites, ...)#
    	return(res)#
    }    	    #
)#
#
setMethod("rowSums",#
	signature(x = "VegsoupData"),#
	function (x, na.rm = FALSE, dims = 1) {#
    	rowSums(as.binary(x))#
    }#
)#
#
setMethod("colSums",#
	signature(x = "VegsoupData"),#
	function (x, na.rm = FALSE, dims = 1) {#
    	colSums(as.binary(x))#
    }#
)#
 #
setMethod("coordinates",#
   signature(obj = "VegsoupData"),#
    function (obj) coordinates(obj@sp.points)#
)#
#
#
setMethod("as.character",#
    signature(x = "VegsoupData"),#
    function (x) {#
    	res <- as.matrix(x@species)#
    	if (mode(res) != "character") {#
	    	mode(res) <- "character"#
    		res <- as.data.frame(res, stringsAsFactors = FALSE)#
    	} else {#
    		res <- x@species#
    	}#
    	return(invisible(res))#
    }#
)	#
#
#
#
setGeneric("as.binary",#
	function (obj, ...)#
		standardGeneric("as.binary")#
)#
#
#
setMethod("as.binary",#
    signature(obj = "VegsoupData"),#
    function (obj) {#
			res <- obj@species != "0"#
		mode(res) <- "numeric"#
		res <- as.data.frame(res)#
		return(invisible(res))#
    }#
)	#
#
#
#
#
setMethod("as.numeric",#
    signature(x = "VegsoupData"),#
    function (x, verbose = FALSE) {#
    	#
		if (AbundanceScale(x)$scale == "frequency" | AbundanceScale(x)$scale == "binary") {#
			res <- as.matrix(x@species)#
			mode(res) <- "numeric"#
			res <- as.data.frame(res)#
			if (verbose) {#
				cat("  species matrix is numeric, scale:",#
					AbundanceScale(x)$scale)#
			}#
		} else {		#
			res <- x@species#
			scale <- AbundanceScale(x)		#
			tmp <- as.factor(c(as.matrix(res)))#
			levels(tmp) <- scale$lims[match(levels(tmp), scale$codes)]#
			tmp <- as.numeric(as.character(tmp))#
			tmp[is.na(tmp)] <- 0#
			res[,] <- tmp#
		}#
		return(invisible(res))   	#
    }#
)#
#
#
setGeneric("Sites",#
	function (obj, ...)#
		standardGeneric("Sites")#
)#
setGeneric("Sites<-",#
	function (obj, value, ...)#
		standardGeneric("Sites<-")#
)#
setMethod("Sites",#
    signature(obj = "VegsoupData"),#
    function (obj) obj@sites#
)#
setReplaceMethod("Sites",#
	signature(obj = "VegsoupData", value = "data.frame"),#
	function (obj, value) {#
		#
		obj@sites <- value		#
		return(obj)		#
	}#
)#
#
setMethod("$", "VegsoupData", #
	function(x, name) {#
		if (!("sites" %in% slotNames(x)))#
			stop("no $ method for object without slot sites")#
		x@sites[[name]]#
	}#
)#
#
#
#
.LayersVegsoupData <- function (obj, collapse, aggregate = c("layer", "mean", "min", "max", "sum"), dec = 0, verbose = FALSE) {#
if (missing(collapse) & missing(aggregate)) {#
	return(obj@layers)	#
} else {#
	if (length(obj@layers) < 2) {#
		if (verbose) warning("has already only a single layer: ", obj@layers)#
		return(obj)#
	} else {#
	#
	#
	if (missing(aggregate)) {#
		aggregate <- "layer"#
	} else {#
		aggregate <- match.arg(aggregate)	#
	}#
	if (missing(collapse)) {#
		if (verbose) cat("collapse to a single layer\n")#
			collapse <- rep("0l", length(obj@layers))#
	} else {#
		if (length(collapse) > length(obj@layers))#
			stop("length of collapse vector must match length(Layers(obj))")#
	}#
	#
	#
	#
	#
	#
	if (inherits(obj, "VegsoupData")) { #
		res <- as(obj, "Vegsoup")#
	} else {#
		res <- obj#
	}#
#
	species <- SpeciesLong(res)#
	scale <- AbundanceScale(res)#
#
	collapse <- matrix(c(res@layers, collapse),#
		ncol = 2, nrow = length(res@layers),#
		byrow = FALSE,#
		dimnames = list(NULL, c("original", "collapsed")))#
	#
	if (verbose) print(collapse)	#
#
	species$layer <- factor(species$layer)#
	levels(species$layer) <- collapse[match(levels(species$layer), collapse[, 1]), 2]#
	species$layer <- as.character(species$layer)#
#
	scale.is.character <- is.character(species$cov)#
	#
	#
	if (scale.is.character) {#
		species$cov <- as.factor(species$cov)#
		levels(species$cov) <- scale$lims[match(levels(species$cov), scale$codes)]#
		species$cov <- as.numeric(as.character(species$cov))#
	}#
	#
	#
	species  <- switch(aggregate, mean = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = mean)#
	}, min = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = min)				#
	}, max = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = max)#
	}, sum = {#
		aggregate(cov ~ plot + abbr + layer, data = species,#
			FUN = sum)#
	}, layer = {#
		if (scale$scale != "frequency") {#
			aggregate(cov ~ plot + abbr + layer, data = species,#
				FUN = function (x) {#
					round((1 - prod(1 - x / max(scale$lims))) * max(scale$lims), dec)#
				})#
		} else {#
			aggregate(cov ~ plot + abbr + layer, data = species,#
				FUN = function (x) {#
					round((1 - prod(1 - x / 100)) * 100, dec)	#
					})#
		}		#
	})#
	#
	species <- species[order(species$plot, species$layer, species$abbr), ]#
	#
	if (scale$scale != "frequency") {#
		if (any(max(species$cov) > max(scale$lims))) {#
			warning("reduced maximum aggregated abundance value to fit into limits: ",#
				min(scale$lims)[1], " to ", max(scale$lims))#
			species$cov[species$cov >  max(scale$lims)] <- max(scale$lims)#
	}#
	}#
	species$cov <- ceiling(species$cov)#
	#
	#
	if (scale.is.character) {	#
		species$cov <- as.factor(species$cov)#
		levels(species$cov) <- scale$codes[match(levels(species$cov), scale$lims)]#
		species$cov <- as.character(species$cov)#
	}#
	#
	res@species.long <- species#
	res@layers <- unique(collapse[, 2])#
	res <- VegsoupData(res)#
	return(invisible(res))#
#
	}#
	}#
}#
#
setMethod("Layers",#
   signature(obj = "VegsoupData"),#
    .LayersVegsoupData#
)#
#
#
.getRichnessVegsoupData <-  function (obj, choice = c("dataset", "sample"), ...) {#
	#
	choices <- c("dataset", "sample")#
	if (missing(choice)) {#
		choice <- "dataset"#
	}#
	choice <- choices[pmatch(choice, choices)]#
	if (is.na(choice)) {#
		choice <- "dataset"#
	}	#
		switch(choice, "dataset" = {#
		res <- length(unique(DecomposeNames(obj))$abbr)#
		}, "sample" = {#
		res <- as.binary(Layers(obj, aggregate = "layer", verbose = FALSE))#
		res <- rowSums(res)#
		})		#
#
	return(res)#
}#
#
setGeneric("Richness",#
	function (obj, ...)#
		standardGeneric("Richness")#
)#
setMethod("Richness",#
    signature(obj = "VegsoupData"),#
    .getRichnessVegsoupData#
)#
#
#
setGeneric("getDistconnected",#
	function (obj, ...)#
		standardGeneric("getDistconnected")#
)#
setMethod("getDistconnected",#
	signature(obj = "VegsoupData"),#
	function (obj, dis = "bray", ...) {#
		distconnected(vegdist(as.numeric(obj), dis), ...)#
	}#
)#
#
.summaryVegsoupData  <- function (object, choice = c("all", "species", "sites"), ...) {#
#
	if (missing(choice)) choice <- "all"#
		choices <- c("all", "species", "sites")#
	choice <- choices[pmatch(choice, choices)]#
	if (is.na(choice)) choice <- "all"#
	cat("object of class", class(object), "\n")#
	species.summary <- paste(#
		Richness(object), " species",#
		"\n", dim(object)[1], " sites (sample plots)",#
		"\nlayers ", length(Layers(object)),#
		" (", paste(Layers(object), collapse = ", "), ")",#
		"\nscale ", AbundanceScale(object)$scale,#
		ifelse(length(object@taxonomy) > 0,#
			"\ntaxomomy lookup table supplied ",#
			"... but has non matching taxa!"),#
		sep = ""#
	)#
#
	switch(choice, "all" = {#
		cat(species.summary)#
		cat("\nsites ")	#
		str(Sites(object), no.list = TRUE)#
	}, "species" = {#
		cat(species.summary)#
	}, "sites" = {#
		cat("\nsites ")#
		str(Sites(object))		#
	})#
}#
#
#
#
setMethod("summary",#
    signature(object = "VegsoupData"),#
	.summaryVegsoupData#
)#
#
#
#
setMethod("show",#
    signature(object = "VegsoupData"),#
    function (object) {#
			summary(object)#
    }#
)#
#
.plotVegsoupData <- function (x, y, ...)#
{	#
	if (!inherits(x, "VegsoupData"))#
		stop("\n need object of class VegsoupData")#
	if (!prod(dim(x)) < 10^5)	#
		cat("Let me calculate capscale first ...")#
	#
	warning("not implemented yet")#
}#
#
#
setMethod("plot",#
	signature(x = "VegsoupData", y = "ANY"),#
	.plotVegsoupData#
)#
#
#
#
setMethod("[",#
    signature(x = "VegsoupData",#
    i = "ANY", j = "ANY", drop = "missing"),#
	function (x, i, j, ..., drop = TRUE)#
    {#
	    #
	    #
	    res <- x#
	    if (missing(i)) i <- rep(TRUE, nrow(res))#
	    if (missing(j)) j <- rep(TRUE, ncol(res))#
#
		ii <- rowSums(as.binary(x)[i,j]) > 0 #
		if (any(ii == FALSE)) {#
			cat("\n removed empty sites:",#
				rownames(x)[i][!ii])	#
		}#
		#
		jj <- colSums(as.binary(x)[i,j]) > 0 #
		if (any(jj == FALSE)) {#
			#
			cat("\nremoved empty species!\n")#
		}#
#
		res@species <- as.character(x)[i,j][ii,jj]#
		res@species.long <-#
			res@species.long[res@species.long$plot %in%	rownames(res), ]#
		res@species.long <-#
			res@species.long[paste(res@species.long$abbr,#
				res@species.long$layer, sep = "@") %in%	names(res), ]#
		res@sites <-#
			res@sites[match(rownames(res),#
				rownames(res@sites)), ]#
		if (any(sapply(res@sites, is.na))) stop("Error")#
		#
		res@sites.long <-#
			res@sites.long[res@sites.long$plot %in%#
				rownames(res), ]#
		res@sites.long <- res@sites.long[order(res@sites.long$plot, res@sites.long$variable), ]#
		if (length(res@group) != 0) {#
		res@group <-#
			res@group[names(res@group) %in%#
				rownames(as.character(x)[i,j][ii,jj])]#
		}#
		#
		abbr <- sapply(strsplit(names(res), "@", fixed = TRUE),#
		   function (x) x[1])#
 		#
		res@taxonomy <- res@taxonomy[res@taxonomy$abbr %in% abbr, ]#
		res@sp.points <- res@sp.points[i,]#
		res@sp.polygons <- res@sp.polygons[i,]#
		res@layers <- as.character(unique(res@species.long$layer))#
	    return(res)#
    }#
)#
#
#
#
#
#
#
#
#
.VegsoupDataArrange <- function (object, method = c("dca", "hclust", "ward", "flexible", "pam", "packed"), dist = "bray", ...) {#
#
if (!inherits(object, "VegsoupData"))#
	stop("Need an object of class VegsoupData")#
#
if (missing(method)) {#
	method  <- "dca"#
	} else {#
	method <- match.arg(method)			#
}#
#
si.dis <- vegdist(as.binary(object), method = dist)#
sp.dis <- vegdist(t(as.binary(object)), method = dist)#
	#
switch(method, dca = {#
	use <- try(decorana(as.binary(object)), silent = TRUE, ...)#
	if (inherits(use, "try-error"))#
		use  <- NULL #
#
	if (is.list(use)) {	#
		tmp <- scores(use, choices = 1, display = "sites")#
		si.ind <- order(tmp)#
		sp.ind <- try(order(scores(use, choices = 1, #
                  display = "species")))#
		if (inherits(sp.ind, "try-error")) #
			sp.ind <- order(wascores(tmp, object))#
	} else {#
			si.ind <- 1:dim(as.binary(object))[1]#
			sp.ind <- 1:dim(as.binary(object))[2]#
	}#
	}, hclust = {#
		si.ind <- hclust(si.dis,#
			method = "ward")$order#
		sp.ind <- hclust(sp.dis,#
			method = "ward")$order#
	}, ward = {#
		si.ind <- agnes(si.dis, diss = TRUE,#
			method = "ward")$order#
		sp.ind <- agnes(sp.dis, diss = TRUE,#
			method = "ward")$order#
	}, flexible = {#
	   	alpha <- 0.625#
	   	beta = 1 - 2 * alpha#
	   	si.ind <- agnes(si.dis, method = "flexible",#
	   		par.meth = c(alpha, alpha, beta, 0))$order#
	   	sp.ind <- agnes(sp.dis, method = "flexible",#
	   		par.meth = c(alpha, alpha, beta, 0))$order#
	}, pam = {#
		si.ind <- agnes(si.dis, diss = TRUE,#
			method = "ward")$order#
		sp.ind <- agnes(sp.dis, diss = TRUE,#
			method = "ward")$order	#
	}, packed = {#
		si.ind <- order(apply(as.binary(object), 1, sum), decreasing = TRUE)#
		sp.ind  <- order(apply(as.binary(object), 2, sum), decreasing = TRUE)#
	}#
)#
	#
res <- object[si.ind, sp.ind]#
#
return(res)#
#
}#
#
#
setGeneric("Arrange",#
	function (object, ...)#
		standardGeneric("Arrange")#
)#
setMethod("Arrange",#
    signature(obj = "VegsoupData"),#
    .VegsoupDataArrange#
)#
#
#
#
			#
setGeneric("Indpower",#
	function (obj, ...)#
		standardGeneric("Indpower")#
)#
#
setMethod("Indpower",#
    signature(obj = "VegsoupData"),#
    function (obj, ...) {#
    	res <- indpower(as.binary(obj), ...)#
    	diag(res)  <- NA#
    	if (type == 0)#
			res <- rowMeans(res, na.rm = TRUE)#
		return(res)    	#
    }#
)#
#
#
#
setGeneric("Indspc",#
	function (obj, ...)#
		standardGeneric("Indspc")#
)#
#
setMethod("Indspc",#
    signature(obj = "VegsoupData"),#
    function (obj, method, ...) {#
    	if (inherits(obj, "VegsoupDataPartition")) {#
    		dis <- vegdist(as.binary(obj), obj@dist)#
    	} else {#
   			if (missing(method)) {    			#
				dis <- vegdist(as.binary(obj), "bray")#
    		} else {#
    			dis <- vegdist(as.binary(obj), ...)#
    		}    		#
  	 	}#
    	res <- indspc(as.binary(obj), dis = dis, ...)#
		return(res)    	#
    }#
)#
#
	#
#
.DecomposeNamesVegsoupData <- function (obj, verbose = FALSE) {#
#
if (verbose)#
	cat("\n use Vegsoup standard pattern taxa coding, blanks are dots")#
#
#
#
	#
#
#
#
abbr <- sapply(strsplit(names(obj), "@", fixed = TRUE),#
		   function (x) x[1])#
layer <- sapply(strsplit(names(obj), "@", fixed = TRUE),#
		   function (x) x[2])#
#
taxon <- Taxonomy(obj)$taxon[match(abbr, Taxonomy(obj)$abbr)]#
res <- data.frame(abbr.layer = names(obj), abbr, layer, taxon, stringsAsFactors = FALSE)#
#
#
if (all(is.na(res$layer))) {#
	warning("unable to deparse layer string, consider setting type to nospace")#
}#
if (all(is.na(res$taxon))) {#
	warning("unable to deparse taxon string, consider setting type to nospace")#
}#
return(invisible(res))#
}#
#
#
setGeneric("DecomposeNames",#
	function (obj, ...)#
		standardGeneric("DecomposeNames")#
)#
#
#
setMethod("DecomposeNames",#
	signature(obj = "VegsoupData"),#
	.DecomposeNamesVegsoupData#
)#
#
#
setMethod("Abbreviation",#
    signature(obj = "VegsoupData"),#
    function (obj, ...) DecomposeNames(dta)$abbr#
)#
#
#
#
#
#
.strideVegsoupData <- function (obj, method, stride, fidelity.method, partition.method, mode, verbose = TRUE, alpha = 0.05, ...) {#
#
	if (missing(fidelity.method))#
		fidelity.method = "IndVal.g"#
	if (missing(partition.method))#
		partition.method = "flexible"#
	if (missing(stride))#
		stride = ceiling(ncol(obj) / 10)#
	if (missing(mode))#
		mode = 0#
	if (verbose) {#
		cat("compute", stride, "partitions for stride")#
		cat("\nrun SigFidelity with mode", mode)#
	}#
#
res <- vector("list", length = stride)#
names(res) <- 1:stride#
#
if (verbose) {#
	pb.stride <- txtProgressBar(min = 1, max = stride,#
	char = '.', width = 45, style = 3)#
}#
#
cpu.time <- system.time({#
for (i in 1:stride) {#
	if (verbose) {#
		setTxtProgressBar(pb.stride, i)#
	}#
	i.prt <- VegsoupDataPartition(obj, k = i, method = partition.method)#
	i.fid <- Fidelity(i.prt, method = fidelity.method, verbose = FALSE)#
	stat.fid <- apply(getStat(i.fid), 1, sum)#
#
	if (i > 1) {#
		i.sig.fid <- SigFidelity(i.prt, verbose = FALSE)#
		i.sig.fid <- length(which(i.sig.fid$stat < alpha))#
	} else {#
		i.sig.fid <- 0#
	}#
	res[[i]] <- list(stat = stat.fid, n.sig = i.sig.fid)#
}#
#
#
stat <- sapply(res, function (x) x[[1]])#
n.sig <- sapply(res, function (x) x$n.sig)#
diff.stat <- t(rbind(0, apply(stat, 1, diff)))#
diff.stat <- apply(diff.stat, 2,#
	function(x)	c(sum(x[x > 0]), sum(x[x < 0])))#
})	#
if (verbose) {#
	close(pb.stride)#
	cat("\n  computed stride in", cpu.time[3], "sec")#
}#
res <- list(#
	stat = stat,#
	n.sig = n.sig,#
	diff.stat = diff.stat)#
	#
return(invisible(res))#
}#
#
setGeneric("Stride",#
	function (obj, ...)#
		standardGeneric("Stride")#
)#
setMethod("Stride",#
	signature(obj = "VegsoupData"),#
	.strideVegsoupData	#
)#
#
#
plotStride <- function (x) {#
#
	xx <- 1:(ncol(x$stat)) #
	y1 <- x$diff.stat[1, ]#
	y2 <- x$diff.stat[2, ]#
	ylim  <- range(x$diff.stat)#
	#
	r1 <- t(rbind(xright = xx - 0.5, ybottom = 0,#
		xright = xx + 0.5, ytop = y1))#
	r2 <- t(rbind(xright = xx - 0.5, ybottom = y2,#
		xright = xx + 0.5, ytop = 0))#
	bars <- cbind(xx, c(x$n.sig))[-1,] #
	#
#
	#
	par(mar= rep(4,4))#
	plot(xx, y1, xlim = c(1, max(xx)),#
		ylim = range(x$diff.stat), type = "n",#
		xlab = "Cluster", ylab = "Index", frame.plot = FALSE) #
	#
	apply(r1, 1, function (x) rect(x[1], x[2], x[3], x[4],#
		col = "grey50"))#
	#
	apply(r2, 1, function (x) rect(x[1], x[2], x[3], x[4],#
		col = "grey90"))#
	#
	plot.window(xlim = range(xx), ylim = range(bars[,2]))#
	lines(xx[-1], bars[,2], type = "b",#
		pch = 16, col = 2, lwd = 2, cex = 1)#
	axis(4, col = 1, lwd = 1)	#
	#
	plot.window(xlim = range(xx),#
		ylim = range(apply(x$diff.stat, 2, sum)))#
	lines(xx, apply(x$diff.stat, 2, sum),#
		type = "b", pch = 15, cex = 1)#
	#
	#
#
#
		#
	legend("top", lty = 1, col = c(1,2),#
		legend = c("sum of all differences",#
		"number of significant indicator species"),#
		bty = "n")#
#
#
#
#
#
#
}
source("/Users/roli/Documents/vegsoup/pkg/R/VegsoupData-Methods.R")
source("/Users/roli/Documents/vegsoup/pkg/R/Vegsoup-Methods.R")
setwd("/Users/roli/Dropbox/cape hallet")#
#
library(vegsoup)#
species <- SpeciesWide2SpeciesLong(file = "./dta/relevees/species wide.csv", verbose = TRUE)#
sites <- SitesWide2SitesLong(file = "./dta/relevees/sites wide.csv")#
taxonomy <- QueryTaxonomy(x = species,#
	file.y = "./dta/relevees/taxonomy.csv")#
qry <- Vegsoup(species, sites, taxonomy, scale = "frequency")
setwd("/Users/roli/Dropbox/cape hallet")#
#
library(vegsoup)#
species <- SpeciesWide2SpeciesLong(file = "./dta/relevees/species wide.csv", verbose = TRUE)#
sites <- SitesWide2SitesLong(file = "./dta/relevees/sites wide.csv")#
taxonomy <- QueryTaxonomy(x = species,#
	file.y = "./dta/relevees/taxonomy.csv")#
qry <- Vegsoup(species, sites, taxonomy, scale = "frequency")
prt <- VegsoupDataPartition(dta, k =1)
dta <- VegsoupData(qry)
setwd("/Users/roli/Dropbox/cape hallet")#
#
library(vegsoup)#
species <- SpeciesWide2SpeciesLong(file = "./dta/relevees/species wide.csv", verbose = TRUE)#
sites <- SitesWide2SitesLong(file = "./dta/relevees/sites wide.csv")#
taxonomy <- QueryTaxonomy(x = species,#
	file.y = "./dta/relevees/taxonomy.csv")#
qry <- Vegsoup(species, sites, taxonomy, scale = "frequency")
slotNames(qry)
AbundanceSclae(qry)
AbundanceScale(qry)
AbundanceScale(qry)
qry@scale
setwd("/Users/roli/Documents/vegsoup/pkg/tests")#
library(vegsoup)#
#
data(dune)#
data(dune.env)#
#
#
#
#
x <- data.frame(abbr = names(dune),#
	layer = c(rep("hl", 8), "ml", rep("hl", 6), "ml", rep("hl", 14)),#
	comment = "", t(dune))#
#
names(x)[4:ncol(x)] <- gsub("X", "dn", names(x)[4:ncol(x)])#
#
species <- SpeciesWide2SpeciesLong(x)#
#
#
#
#
taxon <- c("Bellis perennis", "Leontodon autumnalis", "Poa pratensis",#
	"Trifolium repens", "Achillea millefolium", "Poa trivialis",#
	"Elymus repens", "Lolium perenne", "Alopecuros geniculatuis",#
	"Bormus hordeaceus", "Juncus bufonius", "Ranunculus flammula",#
	"Cheopodium album", "Sagina procumbens", "Agrostis stolonifera",#
	"Brachytethium rutabulum", "Cirsium arvense", "Juncus articulatus",#
	"Eleocharis palustris", "Caliergonella cuspidata", "Rumex acetosa",#
	"Trifolium pratense", "Anthoxanthum odoratum", "Plantago lanceolata",#
	"Aira praecox", "Hypochaeris radicata", "Potentilla palustris",#
	"Vicia latifolia", "Salix repens", "Empetrum nigrum")#
#
taxonomy <- data.frame(abbr = unique(species$abbr), taxon)#
taxonomy <- QueryTaxonomy(x = species, y = taxonomy)#
#
x <- data.frame(plot = row.names(dune.env), dune.env)#
#
x$plot <- paste("dn", x$plot, sep = "")#
#
sites <- SitesWide2SitesLong(x)#
#
#
species$cov <- as.character(cut(as.numeric(species$cov),#
	0:9, c("r", "+", "1", "2m", "2a", "2b", "3", "4", "5")))#
#
qry <- Vegsoup(x = species, y = sites, z = taxonomy)
qry@scale
source("/Users/roli/Documents/vegsoup/pkg/R/Vegsoup-Methods.R")
source("/Users/roli/Documents/vegsoup/pkg/R/Vegsoup-Methods.R")
